// Generated by CoffeeScript 1.4.0
(function() {
  var BLACK_PIXEL, GREY_PIXEL, NEW_PIXEL, PythagorasNode, PythagorasTree, Vector, boundAll, checkPixel, context, cutHex, height, hexToB, hexToG, hexToR, image, setPixel, someTree, width, _ref,
    __slice = [].slice;

  NEW_PIXEL = [0, 0, 0, 0];

  GREY_PIXEL = [120, 120, 120, 120];

  BLACK_PIXEL = [0, 0, 0, 255];

  checkPixel = function(data, idx, pixel) {
    var i, _i;
    for (i = _i = 0; _i < 4; i = ++_i) {
      if (data[idx + i] !== pixel[i]) {
        return false;
      }
    }
    return true;
  };

  setPixel = function(data, idx, pixel) {
    var i, _i;
    for (i = _i = 0; _i < 4; i = ++_i) {
      data[idx + i] = pixel[i];
    }
    return data;
  };

  Vector = (function() {

    function Vector(x, y) {
      this.x = x;
      this.y = y;
    }

    Vector.prototype.add = function(other) {
      return new Vector(this.x + other.x, this.y + other.y);
    };

    Vector.prototype.sub = function(other) {
      return new Vector(this.x - other.x, this.y - other.y);
    };

    Vector.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y;
    };

    Vector.prototype.mult = function(scalar) {
      return new Vector(scalar * this.x, scalar * this.y);
    };

    Vector.prototype.normSquared = function() {
      return this.dot(this);
    };

    Vector.prototype.toString = function() {
      return "(" + this.x + ", " + this.y + ")";
    };

    return Vector;

  })();

  PythagorasNode = (function() {

    function PythagorasNode(origin, basisX, basisY, color, left, right) {
      this.origin = origin;
      this.basisX = basisX;
      this.basisY = basisY;
      this.color = color;
      this.left = left != null ? left : null;
      this.right = right != null ? right : null;
    }

    PythagorasNode.prototype.spawn = function(angle) {
      var cos, leftOrigin, leftX, leftY, newNodes, rightOrigin, rightX, rightY, sin, _ref;
      newNodes = [];
      _ref = [Math.cos(angle), Math.sin(angle)], cos = _ref[0], sin = _ref[1];
      if (this.left != null) {
        newNodes.concat(this.left.spawn(angle));
      } else {
        leftOrigin = this.origin.add(this.basisY);
        leftX = this.basisX.mult(cos * cos).add(this.basisY.mult(sin * cos));
        leftY = this.basisX.mult(-sin * cos).add(this.basisY.mult(cos * cos));
        this.left = new PythagorasNode(leftOrigin, leftX, leftY, this.color);
        newNodes.push(this.left);
      }
      if (this.right != null) {
        newNodes.concat(this.right.spawn(angle));
      } else {
        rightOrigin = this.origin.add(this.basisX.mult(cos * cos).add(this.basisY.mult(sin * cos + 1)));
        rightX = this.basisX.mult(sin * sin).sub(this.basisY.mult(sin * cos));
        rightY = this.basisX.mult(sin * cos).add(this.basisY.mult(sin * sin));
        this.right = new PythagorasNode(rightOrigin, rightX, rightY, this.color);
        newNodes.push(this.right);
      }
      return newNodes;
    };

    PythagorasNode.prototype.bounds = function() {
      var leftBounds, rightBounds, _ref, _ref1;
      leftBounds = (_ref = this.left) != null ? _ref.bounds() : void 0;
      rightBounds = (_ref1 = this.right) != null ? _ref1.bounds() : void 0;
      return boundAll(this.localBounds(), leftBounds, rightBounds);
    };

    PythagorasNode.prototype.localBounds = function() {
      var corners, point, xMax, xMin, yMax, yMin, _i, _len, _ref, _ref1, _ref2, _ref3;
      corners = [this.origin, this.origin.add(this.basisX), this.origin.add(this.basisY), this.origin.add(this.basisX).add(this.basisY)];
      _ref = [this.origin.x, this.origin.y], xMin = _ref[0], yMin = _ref[1];
      _ref1 = [xMin, yMin], xMax = _ref1[0], yMax = _ref1[1];
      for (_i = 0, _len = corners.length; _i < _len; _i++) {
        point = corners[_i];
        _ref2 = [Math.min(xMin, point.x), Math.min(yMin, point.y)], xMin = _ref2[0], yMin = _ref2[1];
        _ref3 = [Math.max(xMax, point.x), Math.max(yMax, point.y)], xMax = _ref3[0], yMax = _ref3[1];
      }
      return {
        min: new Vector(xMin, yMin),
        max: new Vector(xMax, yMax)
      };
    };

    PythagorasNode.prototype.pixelHit = function(globalBounds, pixelNums, pixel) {
      var hitX, hitY, localPoint, nx, ny, scale, scaleX, scaleY, _ref, _ref1, _ref2;
      nx = pixel[0], ny = pixel[1];
      scaleX = (globalBounds.max.x - globalBounds.min.x) / pixelNums[0];
      scaleY = (globalBounds.max.y - globalBounds.min.y) / pixelNums[1];
      scale = Math.max(scaleX, scaleY);
      _ref = [scale, scale], scaleX = _ref[0], scaleY = _ref[1];
      localPoint = new Vector(globalBounds.min.x + scaleX * (nx + 0.5) - this.origin.x, globalBounds.max.y - scaleY * (ny + 0.5) - this.origin.y);
      hitX = (0.0 <= (_ref1 = localPoint.dot(this.basisX)) && _ref1 <= this.basisX.normSquared());
      hitY = (0.0 <= (_ref2 = localPoint.dot(this.basisY)) && _ref2 <= this.basisY.normSquared());
      return hitX && hitY;
    };

    PythagorasNode.prototype.allPossiblePixels = function(globalBounds, pixelNums) {
      var bottomLeft, candidates, localBounds, nx, nxBL, nxTR, ny, nyBL, nyTR, scale, scaleX, scaleY, topRight, _i, _j, _ref, _ref1;
      scaleX = (globalBounds.max.x - globalBounds.min.x) / pixelNums[0];
      scaleY = (globalBounds.max.y - globalBounds.min.y) / pixelNums[1];
      scale = Math.max(scaleX, scaleY);
      _ref = [scale, scale], scaleX = _ref[0], scaleY = _ref[1];
      localBounds = this.localBounds();
      _ref1 = [localBounds.min, localBounds.max], bottomLeft = _ref1[0], topRight = _ref1[1];
      nxBL = Math.floor((bottomLeft.x - globalBounds.min.x) / scaleX);
      nyBL = Math.ceil((globalBounds.max.y - bottomLeft.y) / scaleY) - 1;
      nxTR = Math.ceil((topRight.x - globalBounds.min.x) / scaleX) - 1;
      nyTR = Math.floor((globalBounds.max.y - topRight.y) / scaleY);
      candidates = [];
      for (ny = _i = nyTR; nyTR <= nyBL ? _i <= nyBL : _i >= nyBL; ny = nyTR <= nyBL ? ++_i : --_i) {
        for (nx = _j = nxBL; nxBL <= nxTR ? _j <= nxTR : _j >= nxTR; nx = nxBL <= nxTR ? ++_j : --_j) {
          candidates.push([nx, ny]);
        }
      }
      return candidates;
    };

    PythagorasNode.prototype.allHitPixels = function(globalBounds, pixelNums) {
      var pixel, _i, _len, _ref, _results;
      _ref = this.allPossiblePixels(globalBounds, pixelNums);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pixel = _ref[_i];
        if (this.pixelHit(globalBounds, pixelNums, pixel)) {
          _results.push(pixel);
        }
      }
      return _results;
    };

    PythagorasNode.prototype.render = function(image, globalBounds) {
      var data, idx, pixel, pixelNums, _i, _len, _ref, _ref1, _ref2;
      pixelNums = [image.width, image.height];
      data = image.data;
      _ref = this.allHitPixels(globalBounds, pixelNums);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pixel = _ref[_i];
        idx = (pixel[1] * pixelNums[0] + pixel[0]) * 4;
        if (checkPixel(data, idx, NEW_PIXEL)) {
          setPixel(data, idx, this.color);
        }
      }
      if ((_ref1 = this.left) != null) {
        _ref1.render(image, globalBounds);
      }
      return (_ref2 = this.right) != null ? _ref2.render(image, globalBounds) : void 0;
    };

    PythagorasNode.prototype.toString = function() {
      return "{X:" + this.basisX + ", Y:" + this.basisY + ", O:" + this.origin + ", L:" + this.left + ", R:" + this.right + "}";
    };

    return PythagorasNode;

  })();

  boundAll = function() {
    var boundaries, bounds, xMax, xMin, yMax, yMin, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    boundaries = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!(boundaries.length != null)) {
      return null;
    }
    _ref = [null, null], xMin = _ref[0], yMin = _ref[1];
    _ref1 = [null, null], xMax = _ref1[0], yMax = _ref1[1];
    for (_i = 0, _len = boundaries.length; _i < _len; _i++) {
      bounds = boundaries[_i];
      if (bounds != null) {
        if (!(xMin != null)) {
          _ref2 = [bounds.min.x, bounds.min.y], xMin = _ref2[0], yMin = _ref2[1];
          _ref3 = [bounds.max.x, bounds.max.y], xMax = _ref3[0], yMax = _ref3[1];
        } else {
          _ref4 = [Math.min(xMin, bounds.min.x), Math.min(yMin, bounds.min.y)], xMin = _ref4[0], yMin = _ref4[1];
          _ref5 = [Math.max(xMax, bounds.max.x), Math.max(yMax, bounds.max.y)], xMax = _ref5[0], yMax = _ref5[1];
        }
      }
    }
    return {
      min: new Vector(xMin, yMin),
      max: new Vector(xMax, yMax)
    };
  };

  PythagorasTree = (function() {

    function PythagorasTree(rootLength, angle, order, color) {
      var rootOrigin, rootX, rootY;
      this.rootLength = rootLength;
      this.angle = angle;
      rootOrigin = new Vector(0.0, 0.0);
      rootX = new Vector(rootLength, 0.0);
      rootY = new Vector(0.0, rootLength);
      this.root = new PythagorasNode(rootOrigin, rootX, rootY, color);
      this.expand(order);
    }

    PythagorasTree.prototype.expand = function(extraDepth) {
      var depthToGo, _results;
      depthToGo = extraDepth + 1;
      _results = [];
      while (depthToGo -= 1) {
        _results.push(this.root.spawn(this.angle));
      }
      return _results;
    };

    PythagorasTree.prototype.bounds = function() {
      return this.root.bounds();
    };

    PythagorasTree.prototype.render = function(image) {
      return this.root.render(image, this.bounds());
    };

    PythagorasTree.prototype.toString = function() {
      return this.root.toString();
    };

    return PythagorasTree;

  })();

  if (typeof document !== "undefined" && document !== null) {
    context = canvas.getContext('2d');
    _ref = [canvas.width, canvas.height], width = _ref[0], height = _ref[1];
    image = context.createImageData(width, height);
    someTree = new PythagorasTree(1.0, Math.PI / 4.0, 12, BLACK_PIXEL);
    someTree.render(image);
    context.putImageData(image, 0, 0);
    document.newInput = function() {
      var angle, color, rgb, _ref1;
      context = canvas.getContext('2d');
      _ref1 = [canvas.width, canvas.height], width = _ref1[0], height = _ref1[1];
      image = context.createImageData(width, height);
      color = cutHex(settings.setcolor.value);
      rgb = [hexToR(color), hexToG(color), hexToB(color), 255];
      angle = settings.setangle.value * Math.PI / 180;
      someTree = new PythagorasTree(1.0, angle, 12, rgb);
      someTree.render(image);
      return context.putImageData(image, 0, 0);
    };
  }

  hexToR = function(h) {
    return parseInt((cutHex(h)).substring(0, 2), 16);
  };

  hexToG = function(h) {
    return parseInt((cutHex(h)).substring(2, 4), 16);
  };

  hexToB = function(h) {
    return parseInt((cutHex(h)).substring(4, 6), 16);
  };

  cutHex = function(h) {
    if (h.charAt(0) === "#") {
      return h.substring(1, 7);
    } else {
      return h;
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      PythagorasTree: PythagorasTree,
      Vector: Vector
    };
  }

}).call(this);
